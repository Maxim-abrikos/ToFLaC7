# ToFLaC7
Седьмая лабораторная работа по теории формальных языков и компиляторов  
В скором времени тут появится адекватный текст, а пока что только скриншоты  

Скачал, проверил работоспособность:  
![Снимок экрана (1903)](https://github.com/user-attachments/assets/1284c5fc-4d4f-492a-86d8-053dad63b06e)  


При получении AST Clang выразил негодование из-за своебразного оформления исходных файлов в VS, но при удалении первых строк ошибки исчезли
![Снимок экрана (1904)](https://github.com/user-attachments/assets/5e416bce-6459-4b05-867c-39e60c93c642)  

Генерация промежуточного представления программы:  
![Снимок экрана (1905)](https://github.com/user-attachments/assets/8d08addd-c669-4b28-811d-3204c4596724)  
Остальное в соответствующем файле  

Оптимизация начального уровня:   
![Снимок экрана (1910)](https://github.com/user-attachments/assets/fca84b80-ad0a-4224-9155-699ba036393e)  
Остальное так же в файле

Оптимизация среднего уровня:  
![Снимок экрана (1915)](https://github.com/user-attachments/assets/0d5eab8b-29a4-452b-a84d-4ae8c944a0d0)  

Сравнение файлов (Windows не знает diff, так что используем FC):  
![Снимок экрана (1937)](https://github.com/user-attachments/assets/54ed8743-290a-487a-aae4-a47f60b02abd)  
![Снимок экрана (1938)](https://github.com/user-attachments/assets/0903a265-6581-40c4-835a-f201ea6dd880)  
![Снимок экрана (1939)](https://github.com/user-attachments/assets/76ebe58b-d7e7-4406-b02f-3bc9d5d9ec2f)  
![Снимок экрана (1940)](https://github.com/user-attachments/assets/0e696ffb-4ca4-44ae-bd44-a50cf6fa5e7e)  
![Снимок экрана (1941)](https://github.com/user-attachments/assets/354488c8-cd4e-4bf9-8adf-f204e7041249)  
![Снимок экрана (1942)](https://github.com/user-attachments/assets/cfbdcad3-8f03-4001-8118-aed8d231bde7)  
![Снимок экрана (1943)](https://github.com/user-attachments/assets/78cbe05c-1b8f-4697-a540-f9edb8d08499)  

Генерация оптимизированного LLVM IR:  
![Снимок экрана (1944)](https://github.com/user-attachments/assets/03e2cf3f-9f9c-48d3-9825-9d5ae1dfe4bc)  
Предупреждения - не ошибки, так что идём дальше  

Поток управления программы: 
Windows опять показывает себя не с лучшей стороны - отказывается распознавать команду opt., но ничего страшного - есть онлайн конвертеры из .ll в .dot (потребовалось 4 попытки)  
![Снимок экрана (1960)](https://github.com/user-attachments/assets/53c902cd-73a4-4052-ae35-712269b9ae19)  

После установки Graphviz произошла ещё одна неприятная ситуация - не работает команда dot  
Снова обращаемя за помощью к онлайн конвертерам.  
По итогу получились графы cluster_main и cluster_pow:  
![image](https://github.com/user-attachments/assets/80087529-2430-4eac-97b8-59269a7aa375)



Что такое Clang, и какова его роль в процессе компиляции программ?  
Clang — это передовой инструмент, служащий в качестве входного интерфейса для различных языков программирования, таких как C, C++, Objective-C и OpenCL C, в рамках фреймворка LLVM. Его задача состоит в преобразовании исходного кода в LLVM-совместимый промежуточный код, который затем используется LLVM для оптимизации и генерации исполняемого кода.  

Что представляет собой LLVM и как он используется в современных компиляторах?  
LLVM — это модульная программная платформа, предназначенная для создания компиляторов и связанных инструментов разработки. Он включает в себя модули для обработки исходного кода на разных языках, а также мощную систему оптимизации и генерации машинного кода.  

Чем отличается абстрактное синтаксическое дерево (AST) от промежуточного представления LLVM IR?  
AST представляет собой древовидную структуру, которая отражает синтаксическую организацию исходного кода, показывая взаимосвязь между различными элементами программы. LLVM IR, напротив, является линейным и более низкоуровневым представлением, созданным для оптимизации и генерации кода, независимого от конкретной архитектуры.  

Для чего необходимо промежуточное представление (IR) в процессе компиляции?  
Промежуточное представление служит своеобразным “переводчиком”, позволяя применять одни и те же методы оптимизации и генерации кода к различным языкам программирования, обеспечивая гибкость и повторное использование компонентов компилятора.  

Что делает инструкция alloc в LLVM IR, и зачем она используется в функциях?  
Инструкция alloc зарезервирует область памяти в стеке для хранения локальных переменных, что эквивалентно объявлению переменной внутри функции в языке C.  

Зачем нужна оптимизация кода в компиляторе, и какие основные цели она преследует?  
Оптимизация кода направлена на повышение эффективности работы программы, либо за счет ускорения её выполнения, либо за счет уменьшения занимаемого ею объема памяти.  

Что такое SSA-форма и почему она важна при оптимизации программ?  
SSA (Single Static Assignment) — это особая форма представления кода, при которой каждой переменной присваивается значение только один раз. Такой подход значительно упрощает анализ зависимостей и облегчает проведение оптимизаций.  

Что такое граф потока управления (CFG) и как он помогает анализировать поведение программы?  
CFG — это графическое представление программы, где узлы соответствуют базовым блокам кода, а ребра отражают возможные переходы между ними. CFG позволяет визуализировать и анализировать различные пути выполнения программы, что полезно для оптимизации.  

Как устроено представление арифметических операций в LLVM IR (например, умножение, сложение)?  
Арифметические операции в LLVM IR представлены в виде инструкций, определяющих тип операции и операнды. Например, сложение двух 32-битных целых чисел a и b может выглядеть так: %result = add i32 %a, %b, а умножение — %result = mul i32 %a, %b.  

Почему функции в LLVM IR обычно представляют собой отдельные единицы анализа и оптимизации?  
Функции в LLVM IR спроектированы таким образом, чтобы быть самостоятельными и независимыми единицами, что позволяет компилятору анализировать и оптимизировать их по отдельности.  

Что происходит с функцией в LLVM IR, если она вызывается один раз и очень короткая?  
В таком случае компилятор может принять решение о “встраивании” (inlining) этой функции, то есть замене её вызова на её код непосредственно в месте вызова, что позволяет избежать накладных расходов и дает дополнительные возможности для оптимизации.  

Какие преимущества даёт использование IR и CFG для автоматических оптимизаций по сравнению с анализом исходного текста на C?  
IR обеспечивает более простой и унифицированный формат для анализа, в котором уже устранены многие сложности, присущие исходному коду на C. CFG предоставляет четкую картину потока управления, позволяющую более эффективно применять оптимизации. В результате, оптимизации становятся более надежными, переносимыми и масштабируемыми.  









